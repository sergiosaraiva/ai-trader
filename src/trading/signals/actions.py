"""
Trading Signal Types and Actions.

Defines the output types from the signal generator.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, Optional, Any


class Action(Enum):
    """Trading action enumeration."""
    BUY = "buy"                    # Open long position
    SELL = "sell"                  # Open short position
    HOLD = "hold"                  # No action
    CLOSE_LONG = "close_long"      # Close existing long
    CLOSE_SHORT = "close_short"    # Close existing short
    CLOSE_ALL = "close_all"        # Close all positions


class SignalStrength(Enum):
    """Signal strength levels."""
    VERY_WEAK = "very_weak"        # < 55% confidence
    WEAK = "weak"                  # 55-65% confidence
    MODERATE = "moderate"          # 65-75% confidence
    STRONG = "strong"              # 75-85% confidence
    VERY_STRONG = "very_strong"    # > 85% confidence


@dataclass
class TradingSignal:
    """
    Complete trading signal with all decision information.

    Generated by SignalGenerator, consumed by execution engine.
    """

    # Core signal
    action: Action
    symbol: str
    timestamp: datetime

    # Confidence from model (Beta distribution output)
    confidence: float                     # 0.5 - 1.0, learned from model
    direction_probability: float          # Mean of Beta distribution

    # Beta distribution parameters (for analysis)
    alpha: float = 0.0                    # Evidence for UP
    beta: float = 0.0                     # Evidence for DOWN
    concentration: float = 0.0            # alpha + beta (certainty)

    # Position sizing
    position_size_pct: float = 0.0        # % of equity for this trade
    position_size_units: float = 0.0      # Units/lots to trade

    # Risk management
    stop_loss_price: Optional[float] = None
    stop_loss_pct: float = 0.0            # Stop loss distance as %
    take_profit_price: Optional[float] = None
    take_profit_pct: float = 0.0          # Take profit distance as %
    risk_reward_ratio: float = 0.0

    # Model details
    short_term_signal: float = 0.0        # -1.0 to 1.0
    medium_term_signal: float = 0.0       # -1.0 to 1.0
    long_term_signal: float = 0.0         # -1.0 to 1.0
    ensemble_agreement: float = 0.0       # 0.0 to 1.0

    # Additional context
    signal_strength: SignalStrength = SignalStrength.MODERATE
    reason: str = ""                      # Human-readable reason
    metadata: Dict[str, Any] = field(default_factory=dict)

    @property
    def is_actionable(self) -> bool:
        """Check if signal requires action."""
        return self.action not in [Action.HOLD]

    @property
    def is_entry(self) -> bool:
        """Check if signal is an entry signal."""
        return self.action in [Action.BUY, Action.SELL]

    @property
    def is_exit(self) -> bool:
        """Check if signal is an exit signal."""
        return self.action in [Action.CLOSE_LONG, Action.CLOSE_SHORT, Action.CLOSE_ALL]

    @property
    def direction(self) -> int:
        """Get direction as integer: 1 for long, -1 for short, 0 for hold."""
        if self.action == Action.BUY:
            return 1
        elif self.action == Action.SELL:
            return -1
        return 0

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            'action': self.action.value,
            'symbol': self.symbol,
            'timestamp': self.timestamp.isoformat(),
            'confidence': self.confidence,
            'direction_probability': self.direction_probability,
            'alpha': self.alpha,
            'beta': self.beta,
            'concentration': self.concentration,
            'position_size_pct': self.position_size_pct,
            'stop_loss_pct': self.stop_loss_pct,
            'take_profit_pct': self.take_profit_pct,
            'short_term_signal': self.short_term_signal,
            'medium_term_signal': self.medium_term_signal,
            'long_term_signal': self.long_term_signal,
            'ensemble_agreement': self.ensemble_agreement,
            'signal_strength': self.signal_strength.value,
            'reason': self.reason,
        }

    @classmethod
    def create_hold(cls, symbol: str, reason: str = "No signal") -> 'TradingSignal':
        """Create a HOLD signal."""
        return cls(
            action=Action.HOLD,
            symbol=symbol,
            timestamp=datetime.now(),
            confidence=0.5,
            direction_probability=0.5,
            reason=reason,
        )


def get_signal_strength(confidence: float) -> SignalStrength:
    """Determine signal strength from confidence."""
    if confidence >= 0.85:
        return SignalStrength.VERY_STRONG
    elif confidence >= 0.75:
        return SignalStrength.STRONG
    elif confidence >= 0.65:
        return SignalStrength.MODERATE
    elif confidence >= 0.55:
        return SignalStrength.WEAK
    return SignalStrength.VERY_WEAK
